#[macro_use]
extern crate serde_derive;

extern crate serde_json;

extern crate grabinput;

extern crate chrono;

extern crate regex;

use std::collections::HashMap;

use std::process::Command;

use std::env;

use regex::{Regex};

fn main() {

	
  let args = ["-b28.06.1961",
		  "-ut11.25",
		  "-fPLEBS",
		  "-sid1",
		  "-topo-13.667,65.1,30",
		  "-house-13.667,65.1,W"];

      let args = ["-b28.06.1961",
      "-ut11.25",
      "-ay1"];

  let output = Command::new("swetest")
  	.args(&args)
  	.output().unwrap_or_else(|e| {
	    panic!("failed to execute process: {}", e)
	});
	let txt:String = String::from_utf8_lossy(&output.stdout).into_owned();
  let mut data:HashMap<String,Vec<String>> = HashMap::new();
  let raw_lines = txt.lines();
  for line in raw_lines {
    //let mut parts = clean_line(line).split(" ");
    let li = clean_line(line);
    data.insert(li.key,li.values);

  }
  let serialized = serde_json::to_string(&data).unwrap();
  println!("{}",serialized);

  let args = env ::arga;
}

#[derive(Debug,Serialize, Deserialize)]
struct LineItem {
  key:String,
  values:Vec<String>
}


fn clean_line(line:&str) -> LineItem {
  let ln = line.trim();
  let rgx = Regex::new(r"^([a-zA-Z]\w+)(:|\s\s?(\d+)\s|\s\(?([a-zA-Z]\w+)\)?)?(.*?)$").unwrap();
  let caps = rgx.captures(ln);
  let mut keys:Vec<&str> = Vec::new();
  let mut vals:Vec<String> = Vec::new();
  match caps {
    Some(c) => {
      match c.get(1) {
        Some(m1) => {
          keys.push(m1.as_str());
          match c.get(2) {
            Some(m2) => {
              match c.get(3) {
                Some(m3) => {
                  keys.push(m3.as_str().trim());
                },
                _ => ()
              }
               match c.get(4) {
                Some(m4) => {
                  keys.push(m4.as_str().trim());
                },
                _ => ()
              } 
            },
             _ => ()
          }
        }, 
        _ => ()
      }
      match c.get(5) {
        Some(m5) => {
          let value_string = clean_value_string(m5.as_str());
          let parts = value_string.split(" ");
          for part in parts {
            if part.trim().len() > 0 {
              vals.push(part.trim().to_string());
            }
          }
        },
        _ => ()
      }
    },
    _ => ()
  }
  LineItem {
    key: keys.join("_").to_lowercase(),
    values: vals
  }
}

fn clean_value_string(item:&str) -> String {
  let re = Regex::new(r"(\d[^0-9])\s\s?([0-9])").unwrap();
  re.replace_all(item, "$1$2").into_owned()
}

